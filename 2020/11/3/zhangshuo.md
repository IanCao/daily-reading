#### 原文:https://medium.com/box-tech-blog/cache-is-the-root-of-all-evil-e64ebd7cbd3b

 大概介绍以下几种场景及处理方式

#### 场景一
1. 在大量读请求时，该值因为写请求，导致缓存失效，最终缓存雪崩
2. READER 读取数据后，WRITER 更新数据并使缓存失效，此时 READER 写缓存，导致缓存存储了过期值

#### 解决
1. 引入 lease 概念，用来锁 cache-key
2. 引入两个原子操作：
    * atomic_add(key, value)
    * atomic_check_and_set(key, excepted_value, new_value)
3. 相对传统修改缓存操作，有以下变动：
    * 当缓存失效时，先通过 atomic_add() 把对应的 chche_key 锁住，其他请求返回继续读缓存。这样同一时间，就只会有一个读数据库的请求
    * 当更新缓存时，会先检验该缓存是否被其他操作修改为过期，避免写入过期值

#### 场景二
1. 频繁周期读，同时在周期写。每当读取数据并尝试写入缓存时，写请求把缓存置为无效，导致写缓存失败
2. 多个写请求因此阻塞在 读缓存 这一步

#### 解决
1. 写入 lease 的请求在读取数据成功后，其他等待 lease 的请求也可以读到该数据，并可以直接返回，因为一旦 cache 被写请求置为无效时，lease 也读不到了
2. 本质是让其他请求在值无效前就返回。这样既保证其他请求不读取到无效值，延迟也更低

