# All things caching- use cases, benefits, strategies, choosing a caching technology, exploring some popular products



文章介绍了业务缓存的用途，策略，选型等内容。

## 数据更新

1. 懒加载：读时，没有则更新缓存。缺点：高并发下缓存穿透；缓存过期问题需要考虑。
2. 写后更新：数据写入后，更新缓存。缺点：写缓存失败，则读到过期数据；写多的场景容易数据不一致
3. 更新后写：先更新缓存，再写数据库。缺点：写数据库失败则数据不一致
4. 定期更新：缓存在有效期内被到，则异步更新缓存。缺点：数据最终一致，并不强一致；实现困难
5. 删除后写：删除缓存后，写数据库。缺点：高并发容易造成数据不一致
6. 写后删除：写成功后，删除缓存。缺点：如下文缓存高并发问题；删除失败数据不一致

## 缓存问题

文章中考虑的缓存更新策略比较少，下面结合缓存问题来分析一下比较好的使用方式。常见的缓存问题及应对：

1. 缓存并发：高并发下，数据不在缓存中，容易透过过多请求到数据库。解决：读相同数据加锁和读后通知，避免过多流量打到数据库。
2. 缓存过期：缓存内容同时过期，数据库压力过大。解决：缓存过期时间随机。
3. 缓存穿透：大量查询数据库中不存在的数据，缓存中不会存。造成访问数据库量过大。解决：不存在的数据也缓存，过期时间小一些。
4. 缓存颠簸：缓存集群有主机迁移，造成哈希重排。解决：使用一致性哈希。
5. 缓存故障：缓存异常后，重启缓存被清空。解决：服务限流，缓存预热等。


## 清理策略

1. LRU：最近最少使用。缺点：未考虑使用频率问题
2. LFU：最近最低使用频率。缺点：高频数据被删除后，缓存不退出
3. MRU：最近使用过的，不会再使用，可以直接过期。需要对应使用场景
4. FIFO：先进先出。类似MRU，但是有严格的顺序
5. Redis LFU：结合了LRU 和 LFU，指数计算频率，分钟级计数衰减

## 产品比较

- memcache：纯内存，无持久化
- redis：内存，可持久化，redis cluster 分布式，写业务最常用
- aerospike：分布式缓存，适合存储大量数据，高可用
- hazelcast：分布式缓存，java生态
- couchbase：分布式缓存，文档数据库，功能多


##总结
使用写后删除，缓存有过期时间，结合解决缓存并发的方案，以及Redis LFU，解决高并发读多写少情况下，服务数据库压力过大的问题。

同时，需要想清楚缓存是强依赖还是弱依赖。需要压测有、无缓存情况下，服务的不同极限，再评估对外需要提供的SLO。防止弱依赖缓存被使用成强依赖。另外，就是要做好限流、降级、熔断等预案，预防流量过大、弱依赖故障等问题。

普通缓存需求，redis 足矣；大数据量或单 key 大 size 情况下，使用其他更适合业务场景的方案。选型除了考虑场景，还要考虑稳定、技术成熟度、使用范围、运维成本等，目前看，国内比较广泛的主要还是 redis 和 hbase。