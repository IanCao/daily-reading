讲述关于CPU之间如何实现缓存一致性的文章。很有意思
英文: https://fgiesen.wordpress.com/2014/07/07/cache-coherency/
中文: https://www.infoq.cn/article/cache-coherency-primer

CPU的基本场景
CPU读内存中的数据，必须通过缓存，不会直接去读取内存，因为内存在传统PC上，都会通过内存条的形式存在，电路上相隔比较远，因为电路的距离、电阻等原因，CPU直接读内存，会严重影响CPU的性能。所以大多内存中的数据，都会放在CPU自带的缓存(一般几十字节)中后，才去读取使用。（这个很重要）

* 读操作 - 任意时刻缓存数据和内存数据一致
* 直写(write through) - 类似双写操作，在更新下一级存储（内存或者下一级缓存）的时候，同时更新本级存储，来保障两边数据一致
* 回写(write back) - 一次对某数据的修改，不会直接更改内存，而是先将其缓存标记为“dirty”，脏数据会触发一次回写，在某个时间点再将需要修改的数据，向下一级存储进行回写修改，直到更新到内存
    * 这里我的理解是，在某些时刻，cpu直接操作的缓存的数据，是“新”于真实的内存数据的。
    * 有点像volatile
    * cache数据，要么是随时和memory保持一致，要么是最终需要保持一致
    * 这个存在的意义是，一个数据片段可能会在若干时钟周期内，被重复写多次

CPU缓存一致性协议
对于单核CPU，没啥太大问题。问题在于多核CPU，各自都有各自的缓存，一个核的缓存的数据，在内存中被另一个核修改了，怎么办？

Snooping（窥探）
* 所有内存操作共享一根数据总线，所有核可以知道别的核对内存做了什么

MESI协议(Modified, Exclusive, Shared, Invalid)
一套一致性协议，来保障不同核的缓存数据的顺序一致性。通过定义缓存段的不同状态，来协调不同核之间对数据的读写操作。
* Invalid: 失效状态，代表此数据已过时，等于没缓存的数据，不可读不可写
* Shared：共享状态，代表缓存和主内存数据保持一致。这种状态只能被读取，不能被写入。多个缓存可以同时持有 Shared状态的内存段
* Exclusive
    * 独占，缓存和主内存内容一致，但是只能有一个核持有此状态的内存段。A核将某内存段标记为Exclussive，则其他核缓存中的相同段，立刻进入Invalid
    * 表明“在修改之前，要告诉其他核”的问题
* Modified：已修改，属于脏段，已经被其所属核修改，属于一个修改完成时态的数据段。被标记为M后，其他缓存持有的相同段也会被标记为Invalid

* 只有缓存被标记为E或者M,处理器才能去修改
* 其他处理器想要读取某一段，此段的状态必须从E或者M回到S才行
* 如果处于M，必须完成回写操作到内存，才能够回到S

内存模型 
x86  和 arm，提供了不同强度的内存模型。
在多核场景下，指令重排的存在，在x86和arm，有不同的宽容度。
而是通过不同程序的内存屏障，来保障语义的正确性。（Java中的Happens-before)
现在CPU在处理中，为了提高性能，往往做了很多修改和优化，不能完全按照MESI协议跑。

* 缓存不及时响应总线事件
* 处理器不会严格按照程序顺序向内存发送操作指令
* 写操作分为两部分：获取独占权和执行写，协商获取独占的时候，cpu会做很多其他的事情

这里感觉可以再找一些更细节的文章，结合常用的一些运行指令集或者操作系统，来深入学习。

感想
缓存部分的感想
缓存说来说去其实还是那几个常用的状态，无论是CPU还是分布式
独占、共享、失效
只不过CPU因为其特殊性回写操作的存在，引入了Modified
CPU强大的地方，在于 窥探，通过硬件共享数据总线的方式，来保障窥探的高效正确。
如果在分布式场景，窥探其实很难，需要通过共识算法来达到。

其他的感想
看了这篇后，才终于明白，为什么苹果新出的M1芯片能这么强…
从芯片角度来看，M1做到了
* Arm架构，弱一致性模型，性能天然强于x86，在其自己的系统生态下，能够很大程度的发挥CPU的性能。x86最开始的目的就是能够适配各种不同的机器、场景，而Arm就是专向芯片架构，精简指令集 ，弱一致性模型，都是作证。
* M1把内存做到芯片里面去了…从物理上解决了读写内存的电阻问题，tql，在电脑芯片市场还是第一个



