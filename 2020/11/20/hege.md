这是一篇极佳的科普类技术文章，对于一个软件工程师来说，这样的一篇关于CPU的硬件知识恰当好处，没有深入到枯燥，却也很好地帮助我们理解我们编写的软件在CPU处理时所遇到的问题，以及其解决方式。从中我们能看到属于硬件设计中的独特魅力，也能找到一些我们颇为熟悉的知识与设计方式。某种意义上它让我们从另一个角度审视了自己写的软件代码，这样的不同视角的碰撞，更容易引起我们对编码与软件设计的启发。

### CPU的多级缓存

CPU的实际运算核心并不从主存中读取数据，而是将需要处理的主存数据加载到CPU的L1、L2、L3缓存中进行操作。原因很简单，效率。
那么类比后端缓存的经验我们容易知道，是缓存就一定存在一致性问题，因为数据被多处维护。
在当代多核CPU下，各核心之间的1、2级缓存并不公有，因此，为了程序正确读写必须有机制来避免内存的脏读写。


### MESI协议
MESI协议是一种被广泛用于设计实践的缓存一致性协议（值得注意的是这其实是个通用缓存一致性协议，而并非是CPU特有的，当你的后端服务需要一个高一致性的分布式缓存时，也可以借此来进行设计），它提出通过4个状态来防止各缓存被错误的读取或者使用：

```
Invalid：失效态。此条缓存已失效，再次使用时需要重新载入。
Shared：分享态。可以被读取的状态，但是改条缓存不能被更改。不同核心中的同一条缓存可以同时公有这个状态
Exlusive： 排他态。数据正确，可被读写。排他。
Modified： 已修改态。同Exlusive，只是在下一次回写时，这条内存数据需要回写到主存。
```
MESI有一些变种，但是基本思想一致。一般是会增加一个O或者R/F态还提升效率。
MESI（及其变种）提供的是完备的顺序一致性（sequential consistency）

### 内存模型
CPU实践中，因为物理限制的原因，很难达成MESI协议，也很难实现真正完备的顺序一致性。
通常使用更弱一些的顺序一致性保障。主要方式分两种：
```
第一种是以ARM、Power等架构为代码的弱内存模型，使用内存的读写屏障指令来实现对于内存读写的顺序以及一致性控制。这种模型指令精简，处理简单，执行效率高，但是需要在软件侧来控制读写屏障的插入才能进行正确的运行，对软件工程师的要求更高。

第二种是以x86为代表的强内存模型，通过名为MOB的内存账本，来记录执行的顺序已经缓存读写操作的结果，当指令运行顺序出错时会通过账本数据对缓存已经CPU状态进行回滚。这种方式在硬件层面更好的保障程序的正确性，对软件的宽容度更高，但是相应的执行效率更差。
```

