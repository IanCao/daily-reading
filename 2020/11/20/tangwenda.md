## Cache coherency primer
[原文地址](https://fgiesen.wordpress.com/2014/07/07/cache-coherency/)
缓存，作为一级额外存储单元，最头疼的还是一致性。首先设想单核 CPU 面对的缓存：
* 只考虑读操作，既然缓存是 CPU 可见的内存操作的唯一入口，保证了强一致性
* 考虑写操作，write through & write back两种操作可选
	+ write through: 每次写入时同步传播到下一级存储中
	+ write back：只写入当前缓存，直到缓存失效时才触发写回。可以在存在热点写数据时减少写回频率
	
对于多核的情况，最简单的想法是多核共享一套缓存，这样缓存一致性的问题就消失了，可喜可贺。然而现实是，这样的架构在同一个时钟内只允许单个 CPU 抢占到存储资源，多核的优势被浪费。
* 对于多核，实际上要处理的是多缓存架构下的一致性问题
* 通过 MESI protocol 来模拟共享缓存，每条缓存记录分为四个状态：
	+ Invalid，不可用
	+ Shared，在多个缓存中有副本，只可读
	+ Exclusive，只在当前缓存中有副本，可读写
	+ Modified，被修改过的内容，在其他缓存中必须是 Invalid 状态。等待被写回

比起单核其实就多了个 Exclusice 状态来保证一致性。其他的一些 trick 是基于这个原则之上的，不再展开。
现实是，以上状态机只是理想情况，实际的 CPU 操作缓存时不可能为了一致性放弃效率，来同步得执行这些状态切换操作。不同的架构处理方式不同：
* x86 在内部有一套监听外部事件并回滚的机制，比如写回最终失败了，会回滚相应的操作。指令重排也是有很多保证的，对于开发者而言是一套接近强一致性的模型
* ARM 相对而言会作出更激进的指令重排，也提供了相应的禁止指令重排和提供内存屏障的显示选项给开发者

整体上 CPU 缓存与分布式状况下的缓存还是有很大差别的，毕竟分布式情况下的进程间通信时延高出 N 个量级，还有更大概率会失败。分布式状况下的最终一致性相较于多核情况下的一致性保证弱了很多，后续再看下 raft 吧。